# ═══════════════════════════════════════════════════════════
# NGINX API GATEWAY CONFIGURATION
# ═══════════════════════════════════════════════════════════
# Purpose: Unified entry point for all microservices
# Features: 
#   - Path-based routing to backend services
#   - Rate limiting on public endpoints
#   - Response caching for static content
#   - TLS/SSL support
#   - Request/error logging
#   - CORS handling
#   - Health check aggregation
# ═══════════════════════════════════════════════════════════

user nginx;
worker_processes auto;
error_log /var/log/nginx/error.log warn;
pid /var/run/nginx.pid;

events {
    worker_connections 2048;
    use epoll;
}

http {
    include /etc/nginx/mime.types;
    default_type application/octet-stream;

    # ═══════════════════════════════════════════════════════════
    # LOGGING FORMAT
    # ═══════════════════════════════════════════════════════════
    # Structured JSON-like logging for easy parsing
    log_format main '$remote_addr - $remote_user [$time_local] "$request" '
                    '$status $body_bytes_sent "$http_referer" '
                    '"$http_user_agent" "$http_x_forwarded_for" '
                    'rt=$request_time uct="$upstream_connect_time" '
                    'uht="$upstream_header_time" urt="$upstream_response_time"';

    access_log /var/log/nginx/access.log main;

    # ═══════════════════════════════════════════════════════════
    # PERFORMANCE TUNING
    # ═══════════════════════════════════════════════════════════
    sendfile on;
    tcp_nopush on;
    tcp_nodelay on;
    keepalive_timeout 65;
    types_hash_max_size 2048;
    client_max_body_size 10M;  # Allow up to 10MB uploads (for QR images)

    # Gzip compression
    gzip on;
    gzip_vary on;
    gzip_proxied any;
    gzip_comp_level 6;
    gzip_types text/plain text/css text/xml text/javascript 
               application/json application/javascript application/xml+rss 
               application/rss+xml font/truetype font/opentype 
               application/vnd.ms-fontobject image/svg+xml;

    # ═══════════════════════════════════════════════════════════
    # RATE LIMITING ZONES
    # ═══════════════════════════════════════════════════════════
    # Limit requests per IP address to prevent abuse
    
    # General API rate limit: 100 requests per minute per IP
    limit_req_zone $binary_remote_addr zone=api_limit:10m rate=100r/m;
    
    # Public microsite rate limit: 300 requests per minute per IP
    # (Higher because QR scans generate bursts)
    limit_req_zone $binary_remote_addr zone=public_limit:10m rate=300r/m;
    
    # Auth endpoints: 20 requests per minute per IP
    # (Lower to prevent brute force attacks)
    limit_req_zone $binary_remote_addr zone=auth_limit:10m rate=20r/m;

    # ═══════════════════════════════════════════════════════════
    # RESPONSE CACHE
    # ═══════════════════════════════════════════════════════════
    # Cache rendered microsite HTML (already cached in Redis, but adding nginx layer)
    proxy_cache_path /var/cache/nginx/microsite 
                     levels=1:2 
                     keys_zone=microsite_cache:10m 
                     max_size=100m 
                     inactive=1h 
                     use_temp_path=off;

    # Cache QR images (PNG files don't change once generated)
    proxy_cache_path /var/cache/nginx/qr_images 
                     levels=1:2 
                     keys_zone=qr_cache:10m 
                     max_size=500m 
                     inactive=24h 
                     use_temp_path=off;

    # ═══════════════════════════════════════════════════════════
    # UPSTREAM SERVICE DEFINITIONS
    # ═══════════════════════════════════════════════════════════
    # Point to host machine (services running locally with npm run dev)
    
    upstream auth_service {
        server host.docker.internal:3001 max_fails=3 fail_timeout=30s;
        keepalive 32;
    }

    upstream qr_service {
        server host.docker.internal:3002 max_fails=3 fail_timeout=30s;
        keepalive 32;
    }

    upstream analytics_service {
        server host.docker.internal:3004 max_fails=3 fail_timeout=30s;
        keepalive 32;
    }

    upstream microsite_service {
        server host.docker.internal:3005 max_fails=3 fail_timeout=30s;
        keepalive 64;  # Higher keepalive for high-traffic public endpoint
    }

    upstream ml_service {
        server host.docker.internal:3016 max_fails=3 fail_timeout=30s;
        keepalive 32;
    }

    # ═══════════════════════════════════════════════════════════
    # HTTP SERVER (Port 80)
    # ═══════════════════════════════════════════════════════════
    # Redirect HTTP to HTTPS in production
    # For local dev, this serves traffic directly
    
    server {
        listen 80;
        server_name localhost api.scanly.local;

        # ═══════════════════════════════════════════════════════════
        # HEALTH CHECK ENDPOINT
        # ═══════════════════════════════════════════════════════════
        # Aggregated health check for all services
        location /health {
            access_log off;
            return 200 '{"status":"healthy","gateway":"nginx","timestamp":"$time_iso8601"}';
            add_header Content-Type application/json;
        }

        # ═══════════════════════════════════════════════════════════
        # AUTH SERVICE ROUTES
        # ═══════════════════════════════════════════════════════════
        # /auth/signup, /auth/login, /auth/me, /auth/refresh
        
        location /auth {
            limit_req zone=auth_limit burst=10 nodelay;
            limit_req_status 429;

            proxy_pass http://auth_service;
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection 'upgrade';
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_cache_bypass $http_upgrade;

            # Timeout settings
            proxy_connect_timeout 5s;
            proxy_send_timeout 10s;
            proxy_read_timeout 10s;
        }

        # Auth service Swagger docs
        location /auth-docs {
            rewrite ^/auth-docs(/.*)$ /docs$1 break;
            proxy_pass http://auth_service;
            proxy_http_version 1.1;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        }

        # ═══════════════════════════════════════════════════════════
        # QR SERVICE ROUTES
        # ═══════════════════════════════════════════════════════════
        # POST /generate - Generate new QR code (authenticated)
        # GET /qr/:id - Get QR metadata (authenticated)
        # GET /qr/:id/image - Get QR image PNG (public, cached)
        
        location /generate {
            limit_req zone=api_limit burst=20 nodelay;
            
            proxy_pass http://qr_service;
            proxy_http_version 1.1;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;

            proxy_connect_timeout 5s;
            proxy_send_timeout 10s;
            proxy_read_timeout 10s;
        }

        location /qr {
            limit_req zone=api_limit burst=20 nodelay;
            
            # QR images can be heavily cached (they don't change)
            location ~ ^/qr/[^/]+/image$ {
                proxy_pass http://qr_service;
                proxy_http_version 1.1;
                proxy_set_header Host $host;
                proxy_set_header X-Real-IP $remote_addr;
                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;

                # Enable caching for QR images
                proxy_cache qr_cache;
                proxy_cache_valid 200 24h;
                proxy_cache_valid 404 1m;
                proxy_cache_use_stale error timeout updating http_500 http_502 http_503 http_504;
                proxy_cache_background_update on;
                proxy_cache_lock on;
                add_header X-Cache-Status $upstream_cache_status;

                # CORS for images
                add_header 'Access-Control-Allow-Origin' '*' always;
            }

            # QR metadata (authenticated)
            proxy_pass http://qr_service;
            proxy_http_version 1.1;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }

        # QR service Swagger docs
        location /qr-docs {
            rewrite ^/qr-docs(/.*)$ /docs$1 break;
            proxy_pass http://qr_service;
            proxy_http_version 1.1;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        }

        # ═══════════════════════════════════════════════════════════
        # MICROSITE SERVICE ROUTES
        # ═══════════════════════════════════════════════════════════
        # GET /public/:qrId - Public microsite viewer (high traffic, cached)
        # POST /microsite/:qrId/publish - Publish microsite (authenticated)
        # GET /microsite/:qrId - Get microsite metadata (authenticated)
        # PUT /microsite/:qrId - Update microsite (authenticated)
        
        # Public microsite endpoint (MOST IMPORTANT - this is what users see when scanning QR)
        location /public {
            limit_req zone=public_limit burst=50 nodelay;
            
            proxy_pass http://microsite_service;
            proxy_http_version 1.1;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_set_header User-Agent $http_user_agent;

            # Enable caching for rendered HTML
            proxy_cache microsite_cache;
            proxy_cache_valid 200 5m;  # Cache successful responses for 5 minutes
            proxy_cache_valid 404 1m;  # Cache 404s briefly
            proxy_cache_use_stale error timeout updating http_500 http_502 http_503 http_504;
            proxy_cache_background_update on;
            proxy_cache_lock on;
            proxy_cache_key "$scheme$request_method$host$request_uri";
            add_header X-Cache-Status $upstream_cache_status;

            # Timeouts (rendering can take a bit)
            proxy_connect_timeout 5s;
            proxy_send_timeout 10s;
            proxy_read_timeout 10s;
        }

        # Authenticated microsite management endpoints
        location /microsite {
            limit_req zone=api_limit burst=20 nodelay;
            
            proxy_pass http://microsite_service;
            proxy_http_version 1.1;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;

            proxy_connect_timeout 5s;
            proxy_send_timeout 15s;  # Publishing can take longer
            proxy_read_timeout 15s;
        }

        # Microsite service Swagger docs
        location /microsite-docs {
            rewrite ^/microsite-docs(/.*)$ /docs$1 break;
            proxy_pass http://microsite_service;
            proxy_http_version 1.1;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        }

        # ═══════════════════════════════════════════════════════════
        # ANALYTICS SERVICE ROUTES
        # ═══════════════════════════════════════════════════════════
        # GET /analytics/:qrId/summary - Get analytics summary
        # GET /analytics/:qrId/events - Get raw events
        
        location /analytics {
            limit_req zone=api_limit burst=20 nodelay;
            
            proxy_pass http://analytics_service;
            proxy_http_version 1.1;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;

            proxy_connect_timeout 5s;
            proxy_send_timeout 10s;
            proxy_read_timeout 10s;
        }

        # Analytics service Swagger docs
        location /analytics-docs {
            rewrite ^/analytics-docs(/.*)$ /docs$1 break;
            proxy_pass http://analytics_service;
            proxy_http_version 1.1;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        }

        # ═══════════════════════════════════════════════════════════
        # ML SERVICE ROUTES
        # ═══════════════════════════════════════════════════════════
        # POST /ml/models/train - Train a new ML model
        # GET /ml/models - List all models
        # POST /ml/predict - Make predictions
        # GET /ml/optimal-times - Get optimal posting times
        
        location /ml {
            limit_req zone=api_limit burst=20 nodelay;
            
            proxy_pass http://ml_service;
            proxy_http_version 1.1;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;

            proxy_connect_timeout 30s;
            proxy_send_timeout 60s;
            proxy_read_timeout 60s;
        }

        # AI Generation routes
        location /ai {
            limit_req zone=api_limit burst=10 nodelay;
            
            proxy_pass http://ml_service;
            proxy_http_version 1.1;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;

            proxy_connect_timeout 30s;
            proxy_send_timeout 120s;
            proxy_read_timeout 120s;
        }

        # Accessibility scanning routes
        location /accessibility {
            limit_req zone=api_limit burst=10 nodelay;
            
            proxy_pass http://ml_service;
            proxy_http_version 1.1;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;

            proxy_connect_timeout 30s;
            proxy_send_timeout 60s;
            proxy_read_timeout 60s;
        }

        # Personalization routes
        location /personalization {
            limit_req zone=api_limit burst=20 nodelay;
            
            proxy_pass http://ml_service;
            proxy_http_version 1.1;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;

            proxy_connect_timeout 10s;
            proxy_send_timeout 30s;
            proxy_read_timeout 30s;
        }

        # ═══════════════════════════════════════════════════════════
        # ERROR PAGES
        # ═══════════════════════════════════════════════════════════
        error_page 429 /429.json;
        location /429.json {
            internal;
            return 429 '{"error":"Rate limit exceeded","message":"Too many requests. Please try again later."}';
            add_header Content-Type application/json;
        }

        error_page 502 503 504 /50x.json;
        location /50x.json {
            internal;
            return 503 '{"error":"Service temporarily unavailable","message":"Please try again in a moment."}';
            add_header Content-Type application/json;
        }
    }

    # ═══════════════════════════════════════════════════════════
    # HTTPS SERVER (Port 443) - For Production
    # ═══════════════════════════════════════════════════════════
    # Uncomment and configure for production with real SSL certificates
    
    # server {
    #     listen 443 ssl http2;
    #     server_name api.scanly.io;
    #
    #     # SSL Configuration (Let's Encrypt or other CA)
    #     ssl_certificate /etc/nginx/ssl/fullchain.pem;
    #     ssl_certificate_key /etc/nginx/ssl/privkey.pem;
    #     ssl_protocols TLSv1.2 TLSv1.3;
    #     ssl_ciphers HIGH:!aNULL:!MD5;
    #     ssl_prefer_server_ciphers on;
    #     ssl_session_cache shared:SSL:10m;
    #     ssl_session_timeout 10m;
    #
    #     # Include all location blocks from HTTP server above
    #     # ... (copy all location blocks here)
    # }
}
